package com.ongo.application.video

import com.ongo.application.credit.CreditService
import com.ongo.common.exception.InsufficientCreditException
import com.ongo.domain.video.VideoProcessingProgressRepository
import com.ongo.domain.video.VideoSubtitleRepository
import com.ongo.domain.video.entity.ProcessingStage
import com.ongo.domain.video.entity.VideoSubtitle
import org.slf4j.LoggerFactory
import org.springframework.scheduling.annotation.Async
import org.springframework.stereotype.Component
import org.springframework.transaction.event.TransactionPhase
import org.springframework.transaction.event.TransactionalEventListener
import java.net.URI
import java.nio.file.Files
import java.nio.file.Path

@Component
class CaptionGenerationListener(
    private val subtitleRepository: VideoSubtitleRepository,
    private val progressRepository: VideoProcessingProgressRepository,
    private val creditService: CreditService,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    companion object {
        private const val CAPTION_CREDIT_COST = 5
    }

    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, fallbackExecution = true)
    fun handleCaptionGeneration(event: CaptionGenerationEvent) {
        log.info("자막 생성 시작: videoId={}, language={}", event.videoId, event.language)

        // AI 크레딧 차감
        try {
            creditService.validateAndDeduct(event.userId, CAPTION_CREDIT_COST, "CAPTION_GENERATION")
        } catch (e: InsufficientCreditException) {
            log.warn("자막 생성 스킵 (크레딧 부족): videoId={}, userId={}", event.videoId, event.userId)
            progressRepository.upsertProgress(event.videoId, ProcessingStage.CAPTION, null, 100, "스킵 (크레딧 부족)")
            return
        }

        val tempDir = Path.of("/tmp/ongo-caption/${event.videoId}")
        Files.createDirectories(tempDir)
        val inputFile = tempDir.resolve("audio.mp4")

        try {
            progressRepository.upsertProgress(event.videoId, ProcessingStage.CAPTION, null, 0, "자막 생성 준비 중")

            // Download original
            URI(event.fileUrl).toURL().openStream().use { input ->
                Files.copy(input, inputFile)
            }

            progressRepository.upsertProgress(event.videoId, ProcessingStage.CAPTION, null, 20, "Whisper STT 실행 중")

            // Run Whisper for transcription
            val srtContent = runWhisperTranscription(inputFile, event.language)

            if (srtContent.isNotBlank()) {
                subtitleRepository.save(
                    VideoSubtitle(
                        videoId = event.videoId,
                        language = event.language,
                        format = "srt",
                        content = srtContent,
                        isAutoGenerated = true,
                    )
                )
                progressRepository.upsertProgress(event.videoId, ProcessingStage.CAPTION, null, 100, "자막 생성 완료")
                log.info("자막 생성 완료: videoId={}", event.videoId)
            } else {
                progressRepository.upsertProgress(event.videoId, ProcessingStage.CAPTION, null, 100, "자막 없음 (음성 감지 실패)")
                log.info("자막 생성 결과 없음: videoId={}", event.videoId)
            }
        } catch (e: java.io.FileNotFoundException) {
            log.error("자막 생성 실패 (파일 없음): videoId={}", event.videoId, e)
            progressRepository.upsertProgress(event.videoId, ProcessingStage.CAPTION, null, 0, "실패: 파일을 찾을 수 없습니다")
        } catch (e: java.io.IOException) {
            log.error("자막 생성 파일 I/O 오류: videoId={}", event.videoId, e)
            progressRepository.upsertProgress(event.videoId, ProcessingStage.CAPTION, null, 0, "실패: 파일 처리 오류")
        } catch (e: Exception) {
            log.error("자막 생성 예기치 않은 오류: videoId={}", event.videoId, e)
            progressRepository.upsertProgress(event.videoId, ProcessingStage.CAPTION, null, 0, "실패: ${e.message?.take(200)}")
        } finally {
            try {
                Files.deleteIfExists(inputFile)
                Files.deleteIfExists(tempDir)
            } catch (e: java.io.IOException) {
                log.debug("임시 파일 정리 실패: {}", e.message)
            }
        }
    }

    private fun runWhisperTranscription(inputFile: Path, language: String): String {
        // Extract audio first
        val audioFile = inputFile.parent.resolve("audio.wav")
        val extractCmd = listOf(
            "ffmpeg", "-i", inputFile.toString(),
            "-vn", "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1",
            "-y", audioFile.toString(),
        )

        val extractProcess = ProcessBuilder(extractCmd).redirectErrorStream(true).start()
        extractProcess.inputStream.bufferedReader().readText()
        if (extractProcess.waitFor() != 0) {
            throw RuntimeException("오디오 추출 실패")
        }

        // Run Whisper CLI
        val outputBase = inputFile.parent.resolve("subtitle")
        val whisperCmd = listOf(
            "whisper",
            audioFile.toString(),
            "--model", "base",
            "--language", language,
            "--output_format", "srt",
            "--output_dir", inputFile.parent.toString(),
        )

        try {
            val whisperProcess = ProcessBuilder(whisperCmd).redirectErrorStream(true).start()
            whisperProcess.inputStream.bufferedReader().readText()
            val exitCode = whisperProcess.waitFor()

            if (exitCode != 0) {
                log.warn("Whisper 실행 실패 (exit={}), 빈 자막 반환", exitCode)
                return ""
            }

            // Find generated SRT file
            val srtFile = Files.list(inputFile.parent)
                .filter { it.toString().endsWith(".srt") }
                .findFirst()
                .orElse(null)

            return if (srtFile != null && Files.exists(srtFile)) {
                Files.readString(srtFile)
            } else {
                ""
            }
        } catch (e: InterruptedException) {
            Thread.currentThread().interrupt()
            log.error("Whisper 프로세스 중단됨", e)
            return ""
        } catch (e: java.io.IOException) {
            log.warn("Whisper를 찾을 수 없습니다 (설치 필요): {}", e.message)
            return ""
        } finally {
            Files.deleteIfExists(audioFile)
        }
    }
}
