<template>
  <div class="card">
    <!-- Header -->
    <div class="mb-4 flex flex-wrap items-center justify-between gap-3">
      <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">
        {{ t('video.caption.title') }}
      </h3>

      <!-- Language Selector -->
      <div class="flex items-center gap-2">
        <label for="caption-language" class="text-sm text-gray-600 dark:text-gray-400">
          {{ t('video.caption.language') }}
        </label>
        <select
          id="caption-language"
          v-model="selectedLanguage"
          class="input w-28 text-sm"
          @change="loadCaptions"
        >
          <option
            v-for="lang in languages"
            :key="lang.code"
            :value="lang.code"
          >
            {{ lang.label }}
          </option>
        </select>
      </div>
    </div>

    <!-- Loading State -->
    <div v-if="loading" class="flex items-center justify-center py-12">
      <div class="h-8 w-8 animate-spin rounded-full border-2 border-gray-300 border-t-primary-600 dark:border-gray-600" />
    </div>

    <!-- Content Area -->
    <div v-else>
      <!-- Auto-generated Badge -->
      <div v-if="currentCaption?.isAutoGenerated" class="mb-3">
        <span class="inline-flex items-center gap-1 rounded-full bg-blue-100 px-2.5 py-1 text-xs font-medium text-blue-700 dark:bg-blue-900/30 dark:text-blue-400">
          <SparklesIcon class="h-3.5 w-3.5" />
          {{ t('video.caption.autoGenerated') }}
        </span>
      </div>

      <!-- Empty State -->
      <div
        v-if="!currentCaption && !loading"
        class="flex flex-col items-center justify-center rounded-lg border-2 border-dashed border-gray-300 py-12 dark:border-gray-600"
      >
        <LanguageIcon class="mb-3 h-10 w-10 text-gray-400 dark:text-gray-500" />
        <p class="mb-4 text-sm text-gray-500 dark:text-gray-400">
          {{ t('video.caption.empty') }}
        </p>
        <button
          class="btn-primary inline-flex items-center gap-1.5 text-sm"
          :disabled="generating"
          @click="handleGenerate"
        >
          <SparklesIcon class="h-4 w-4" />
          {{ t('video.caption.generate') }}
        </button>
      </div>

      <!-- Caption Editor -->
      <div v-else-if="currentCaption">
        <!-- Textarea -->
        <textarea
          v-model="editedContent"
          class="input min-h-[240px] w-full resize-y font-mono text-sm leading-relaxed"
          :placeholder="t('video.caption.placeholder')"
          :disabled="saving || generating"
        />

        <!-- Character Count -->
        <div class="mt-2 flex items-center justify-between">
          <p class="text-xs text-gray-500 dark:text-gray-400">
            {{ editedContent.length }} {{ t('video.caption.characters') }}
          </p>
          <p
            v-if="hasChanges"
            class="text-xs font-medium text-amber-600 dark:text-amber-400"
          >
            {{ t('video.caption.unsavedChanges') }}
          </p>
        </div>

        <!-- Action Buttons -->
        <div class="mt-4 flex flex-wrap items-center justify-between gap-3 border-t border-gray-200 pt-4 dark:border-gray-700">
          <!-- Left: Generate & Save -->
          <div class="flex items-center gap-2">
            <button
              class="btn-secondary inline-flex items-center gap-1.5 text-sm"
              :disabled="generating"
              @click="handleGenerate"
            >
              <SparklesIcon class="h-4 w-4" />
              <span v-if="generating">{{ t('video.caption.generating') }}</span>
              <span v-else>{{ t('video.caption.regenerate') }}</span>
            </button>
            <button
              class="btn-primary inline-flex items-center gap-1.5 text-sm"
              :disabled="saving || !hasChanges"
              @click="handleSave"
            >
              <span v-if="saving">{{ t('action.loading') }}</span>
              <span v-else>{{ t('action.save') }}</span>
            </button>
          </div>

          <!-- Right: Download Buttons -->
          <div class="flex items-center gap-2">
            <button
              class="btn-secondary inline-flex items-center gap-1.5 text-sm"
              :disabled="!currentCaption"
              @click="downloadAs('srt')"
            >
              <ArrowDownTrayIcon class="h-4 w-4" />
              SRT
            </button>
            <button
              class="btn-secondary inline-flex items-center gap-1.5 text-sm"
              :disabled="!currentCaption"
              @click="downloadAs('vtt')"
            >
              <ArrowDownTrayIcon class="h-4 w-4" />
              VTT
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Credit Cost Warning (shown before generation) -->
    <div
      v-if="showCreditWarning"
      class="fixed inset-0 z-50 flex items-center justify-center p-4"
      role="dialog"
      aria-modal="true"
    >
      <div class="fixed inset-0 bg-black/60 backdrop-blur-sm" @click="showCreditWarning = false" />
      <div class="relative w-full max-w-sm rounded-xl border border-gray-200 bg-white p-6 shadow-2xl dark:border-gray-700 dark:bg-gray-800">
        <h4 class="mb-2 text-base font-semibold text-gray-900 dark:text-gray-100">
          {{ t('video.caption.creditWarningTitle') }}
        </h4>
        <p class="mb-4 text-sm text-gray-600 dark:text-gray-400">
          {{ t('video.caption.creditWarningMessage', { credits: CAPTION_CREDIT_COST }) }}
        </p>
        <div class="flex justify-end gap-2">
          <button
            class="btn-secondary text-sm"
            @click="showCreditWarning = false"
          >
            {{ t('action.cancel') }}
          </button>
          <button
            class="btn-primary text-sm"
            @click="confirmGenerate"
          >
            {{ t('action.confirm') }}
          </button>
        </div>
      </div>
    </div>

    <!-- Error Message -->
    <div
      v-if="errorMessage"
      class="mt-4 flex items-center gap-2 rounded-lg bg-red-50 px-4 py-3 dark:bg-red-900/20"
    >
      <ExclamationTriangleIcon class="h-4 w-4 flex-shrink-0 text-red-500" />
      <p class="text-sm text-red-700 dark:text-red-400">{{ errorMessage }}</p>
    </div>

    <!-- Success Message -->
    <Transition
      enter-active-class="transition-opacity duration-300"
      enter-from-class="opacity-0"
      enter-to-class="opacity-100"
      leave-active-class="transition-opacity duration-200"
      leave-from-class="opacity-100"
      leave-to-class="opacity-0"
    >
      <div
        v-if="showSuccess"
        class="mt-4 flex items-center gap-2 rounded-lg bg-green-50 px-4 py-3 dark:bg-green-900/20"
      >
        <CheckCircleIcon class="h-4 w-4 flex-shrink-0 text-green-500" />
        <p class="text-sm text-green-700 dark:text-green-400">{{ t('video.caption.saved') }}</p>
      </div>
    </Transition>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { useI18n } from 'vue-i18n'
import {
  SparklesIcon,
  LanguageIcon,
  ArrowDownTrayIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
} from '@heroicons/vue/24/outline'
import { videoApi } from '@/api/video'
import type { VideoSubtitle } from '@/types/video'

// ---- i18n ----

const { t } = useI18n({ useScope: 'global' })

// ---- Props ----

const props = defineProps<{
  videoId: number
}>()

// ---- Constants ----

const CAPTION_CREDIT_COST = 5

const languages = [
  { code: 'ko', label: '한국어' },
  { code: 'en', label: 'English' },
] as const

// ---- State ----

const selectedLanguage = ref<string>('ko')
const captions = ref<VideoSubtitle[]>([])
const editedContent = ref('')
const loading = ref(false)
const saving = ref(false)
const generating = ref(false)
const showCreditWarning = ref(false)
const errorMessage = ref<string | null>(null)
const showSuccess = ref(false)

let successTimeout: ReturnType<typeof setTimeout> | null = null

// ---- Computed ----

const currentCaption = computed(() => {
  return captions.value.find((c) => c.language === selectedLanguage.value) ?? null
})

const hasChanges = computed(() => {
  if (!currentCaption.value) return false
  return editedContent.value !== currentCaption.value.content
})

// ---- Watchers ----

watch(currentCaption, (newCaption) => {
  if (newCaption) {
    editedContent.value = newCaption.content
  } else {
    editedContent.value = ''
  }
})

// ---- Methods ----

/** Load captions from API */
async function loadCaptions() {
  loading.value = true
  errorMessage.value = null

  try {
    captions.value = await videoApi.getCaptions(props.videoId)
  } catch {
    errorMessage.value = t('video.caption.loadError')
  } finally {
    loading.value = false
  }
}

/** Show credit warning before generating */
function handleGenerate() {
  errorMessage.value = null
  showCreditWarning.value = true
}

/** Confirm and start caption generation */
async function confirmGenerate() {
  showCreditWarning.value = false
  generating.value = true
  errorMessage.value = null

  try {
    await videoApi.generateCaption(props.videoId, selectedLanguage.value)
    // Reload captions after generation
    await loadCaptions()
  } catch {
    errorMessage.value = t('video.caption.generateError')
  } finally {
    generating.value = false
  }
}

/** Save edited caption content */
async function handleSave() {
  if (!hasChanges.value) return

  saving.value = true
  errorMessage.value = null

  try {
    const updated = await videoApi.updateCaption(
      props.videoId,
      selectedLanguage.value,
      editedContent.value,
    )
    // Update local data
    const idx = captions.value.findIndex((c) => c.language === selectedLanguage.value)
    if (idx >= 0) {
      captions.value[idx] = updated
    } else {
      captions.value.push(updated)
    }
    flashSuccess()
  } catch {
    errorMessage.value = t('video.caption.saveError')
  } finally {
    saving.value = false
  }
}

/** Download caption in specified format */
function downloadAs(format: 'srt' | 'vtt') {
  if (!currentCaption.value) return

  const content = format === 'vtt'
    ? convertToVtt(currentCaption.value.content)
    : currentCaption.value.content

  const mimeType = format === 'vtt' ? 'text/vtt' : 'text/srt'
  const extension = format
  const filename = `caption_${selectedLanguage.value}.${extension}`

  const blob = new Blob([content], { type: `${mimeType};charset=utf-8` })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

/** Convert SRT content to VTT format */
function convertToVtt(srtContent: string): string {
  const vttHeader = 'WEBVTT\n\n'
  // Replace SRT timestamp format (comma) with VTT format (period)
  const converted = srtContent.replace(/(\d{2}:\d{2}:\d{2}),(\d{3})/g, '$1.$2')
  return vttHeader + converted
}

/** Show success message temporarily */
function flashSuccess() {
  showSuccess.value = true
  if (successTimeout) clearTimeout(successTimeout)
  successTimeout = setTimeout(() => {
    showSuccess.value = false
  }, 3000)
}

// ---- Lifecycle ----

onMounted(() => {
  loadCaptions()
})
</script>
